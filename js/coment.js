// Ключ до API
const API_KEY = '39484485-dccfbf14586dc449f78b39dc0';

// Початковий пошуковий запит
let currentQuery = '';// Цей рядок створює нову змінну під назвою currentPage і присвоює їй значення 1. currentPage використовується для відстеження поточної сторінки зображень, які завантажуються з API. Коли користувач запитує зображення за допомогою пошукової форми або кнопки "Завантажити ще", ця змінна допомагає визначити, яку саме сторінку зображень потрібно завантажити наступною. Значення 1 вказує, що за замовчуванням завантажується перша сторінка зображень.

// Елементи інтерфейсу
const gallery = document.querySelector('.gallery'); //Цей рядок коду створює константу (змінну, яка не може бути змінена після ініціалізації) під назвою gallery. Він використовує метод document.querySelector('.gallery'), щоб знайти перший елемент у DOM (структурі веб-сторінки), який відповідає селектору CSS .gallery. Селектор .gallery вказує на елемент з класом "gallery". Тому змінна gallery тепер містить посилання на цей елемент, і ви можете взаємодіяти з ним у вашому коді.
const searchForm = document.getElementById('search-form');//Цей рядок коду створює константу під назвою searchForm. Він використовує метод document.getElementById('search-form'), щоб знайти елемент у DOM, який має атрибут id зі значенням "search-form". Тому змінна searchForm тепер містить посилання на цей елемент. Це зазвичай форма пошуку на веб-сторінці.
const searchIcon = document.querySelector('.search-icon');//Цей рядок коду створює константу під назвою searchIcon. Він використовує метод document.querySelector('.search-icon'), щоб знайти перший елемент у DOM, який відповідає селектору CSS .search-icon. Селектор .search-icon вказує на елемент з класом "search-icon". Тому змінна searchIcon тепер містить посилання на цей елемент, і це, ймовірно, іконка пошуку на веб-сторінці.

// Обробник події для пошукової іконки
searchIcon.addEventListener('click', () => {//Цей рядок починає додавання обробника подій до елемента searchIcon. Цей обробник відреагує на подію "клік" (тобто коли користувач клікає на іконку пошуку).
    gallery.innerHTML = '';  // Тут ми обнулюємо (очищуємо) внутрішній HTML контент елемента gallery. Це означає, що всі зображення, які були показані в галереї до цього, будуть видалені. Це корисно, щоб гарантувати, що нові результати пошуку не будуть додані до попередніх результатів, а замість цього покажуть лише нові зображення.
    currentQuery = searchForm.elements.searchQuery.value;  // Тут ми отримуємо значення, введене користувачем у поле пошукової форми. searchForm.elements.searchQuery.value отримує введене значення з елемента форми з ім'ям searchQuery. Це значення потім зберігається у змінній currentQuery, яка використовується для зберігання поточного пошукового запиту.
    fetchImages(currentQuery);  // Виклик функції fetchImages із змінною currentQuery як параметром. Ця функція відповідає за виконання HTTP-запиту до API зображень Pixabay і отримання зображень, які відповідають пошуковому запиту користувача. Після завантаження цих зображень вони будуть відображені в галереї.
});

// Обробник події для форми пошуку. 
searchForm.addEventListener('submit', (event) => { // Цей блок коду слугує для того, щоб при надсиланні форми (наприклад, коли користувач натискає Enter у полі форми) очистити поточний контент галереї, отримати новий пошуковий запит від користувача та завантажити відповідні зображення.
    event.preventDefault();  // Запобігаємо стандартній поведінці форми під час її відправки. Зазвичай, форма після відправки перезавантажує сторінку. Тут ми цього не хочемо, тому викликаємо цей метод.
    gallery.innerHTML = '';  // Очищуємо вміст галереї. Замінюємо весь HTML контент галереї на пустий рядок, тобто видаляємо всі поточні зображення.
    currentQuery = event.currentTarget.elements.searchQuery.value;  // Отримуємо значення, введене користувачем у поле форми (з ім'ям "searchQuery"). Це і буде наш новий пошуковий запит.
    fetchImages(currentQuery);  // Викликаємо функцію fetchImages з новим пошуковим запитом, щоб отримати та відобразити зображення відповідно до цього запиту.

});


// Обробник події для кнопки "Завантажити ще" цей блок коду визначає, що коли користувач клікає на кнопку "Завантажити ще" (loadMoreBtn), буде викликана функція fetchImages для завантаження наступної сторінки зображень відповідно до поточного пошукового запиту.
const loadMoreBtn = document.getElementById('loadMoreBtn');//Цей рядок коду створює константу (змінну, яку не можна змінювати) з назвою loadMoreBtn.Він використовує вбудований метод document.getElementById для отримання доступу до HTML-елемента з ідентифікатором loadMoreBtn. Це зазвичай кнопка на веб-сторінці, яку користувач може натиснути, щоб завантажити більше зображень.
loadMoreBtn.addEventListener('click', () => {//Цей рядок коду починає додавати обробник події до елемента loadMoreBtn. Обробник буде реагувати на подію click (коли користувач клікає на кнопку).Функція-стрілка () => { це анонімна функція, яка буде викликана, коли користувач клікає на loadMoreBtn.
    fetchImages(currentQuery, currentPage + 1);  // Цей рядок коду викликає функцію fetchImages і передає їй поточний пошуковий запит (currentQuery) і номер наступної сторінки (currentPage + 1).Функція fetchImages відповідає за завантаження зображень з вказаної сторінки відповідно до пошукового запиту.
});

// Обробник події для кнопки "Прокрутити до початку"
const scrollToTopBtn = document.getElementById('scrollToTopBtn');//В цьому рядку ми створюємо константу (змінну, яку не можна змінити) з ім'ям scrollToTopBtn. Функція document.getElementById('scrollToTopBtn') шукає в DOM (структурі документа) елемент з ідентифікатором 'scrollToTopBtn' і повертає його. Тобто, ми отримуємо посилання на кнопку "Прокрутити до початку" і зберігаємо його в змінній scrollToTopBtn.
scrollToTopBtn.addEventListener('click', () => {//Тут ми додаємо обробник події до кнопки scrollToTopBtn. Коли користувач клікає на кнопку, функція, яку ми передаємо як другий аргумент, буде виконана.
    window.scrollTo({//Ця команда прокручує вікно браузера.
        top: 0,  // Це параметр для window.scrollTo(). Він вказує, що ми хочемо прокрутити вікно до початку сторінки (верхньої частини). Значення 0 вказує на самий верх сторінки.
        behavior: 'smooth'  // Це також параметр для window.scrollTo(). Він вказує на те, як ми хочемо прокрутити сторінку. Значення 'smooth' означає, що прокрутка буде виконуватися плавно, а не миттєво.
    });
    smoothScrollToTop(4000);//Після того, як ми прокрутили сторінку до початку за допомогою window.scrollTo(), ми викликаємо функцію smoothScrollToTop(4000);. Ця функція, судячи з назви, також відповідає за плавну прокрутку до початку сторінки і приймає параметр часу (4000 мілісекунд, або 4 секунди), протягом якого відбудеться прокрутка.
});

// Змінна для відстеження стану завантаження
let isFetching = false;// let - це ключове слово у JavaScript, яке використовується для оголошення змінних. Змінні оголошені за допомогою let мають блочну область видимості. isFetching - це ім'я змінної. Ім'я було обрано таким чином, щоб відображати її призначення: відстежувати, чи в даний момент відбувається процес завантаження. = - це оператор присвоєння у JavaScript. Він використовується для присвоєння значення змінній. false - це булеве значення у JavaScript, яке може приймати два стани: true (істина) або false (брехня). У цьому контексті false вказує на те, що в даний момент завантаження не відбувається. Отже, цей рядок коду оголошує змінну isFetching і відразу присвоює їй значення false, що вказує на те, що в даний момент немає активного процесу завантаження

// Змінна для слідкування поточного етапу прокрутки
let scrollStage = 0;// let: Це ключове слово в JavaScript, яке використовується для оголошення змінної. Змінна - це ім'я, яке вказує на певне значення або об'єкт в пам'яті. Ви можете використовувати цю змінну для зберігання, отримання або зміни значення. scrollStage: Це ім'я змінної, яке ви вибрали. Ця конкретна змінна використовується для відстеження поточного "етапу" прокрутки користувача на веб-сторінці. = 0;: Це присвоєння значення змінній. Зі значенням 0 ви встановлюєте початковий стан для scrollStage. За вашим кодом, 0 може означати, що користувач ще не прокрутив сторінку до кінця (або до певного місця, де ви хочете відображати додатковий контент або кнопку). Отже, цей рядок коду створює нову змінну з ім'ям scrollStage і встановлює її початкове значення рівним 0. В майбутньому ви можете змінювати це значення в залежності від дій користувача на веб-сторінці.

// Змінні для слідкування різних стадій прокрутки
let hasScrolledPastImages = false;//Ця змінна, ймовірно, була створена для відстеження, чи користувач прокрутив сторінку за межі зображень. Якщо користувач прокрутить сторінку так, що зображення будуть вище за область видимості, ця змінна має бути встановлена в true. За замовчуванням вона встановлена в false, тобто користувач ще не прокрутив сторінку за межі зображень.
let hasScrolledToButton = false;//Ця змінна, ймовірно, призначена для відстеження, чи користувач прокрутив сторінку до кнопки "Завантажити ще" або будь-якої іншої кнопки. Коли користувач прокручує сторінку вниз і доходить до цієї кнопки, ця змінна має бути встановлена в true. За замовчуванням вона встановлена в false, що означає, що користувач ще не досяг кнопки.
let isLoadMoreButtonFocused = false;//Ця змінна використовується для визначення, чи знаходиться кнопка "Завантажити ще" у фокусі. Якщо користувач клікає на кнопку або переходить на неї за допомогою клавіатури, ця кнопка отримує фокус, і ця змінна стає true. За замовчуванням вона false, тобто кнопка не у фокусі.

// Змінні для слідкування різних стадій завантаження зображень
let hasReachedEndOfImages = false;//Ця змінна вказує, чи дійшов користувач до кінця поточного списку зображень. Якщо користувач проскролює до кінця галереї, але нові зображення ще не завантажені, ця змінна буде встановлена в true.
let hasDisplayedButton = false;//Ця змінна вказує, чи була вже відображена кнопка "Завантажити ще". Якщо кнопка вже показана користувачеві, ця змінна буде встановлена в true.
let scrollCountsAfterReset = 0;//Ця змінна використовується для підрахунку кількості прокруток, які зробив користувач, після того як деякі параметри були скинуті (наприклад, після завантаження нового набору зображень). Якщо користувач зробить певну кількість прокруток (наприклад, 2), можливо, буде здійснено певну дію, таку як автоматичне завантаження нових зображень.

// Функція для гладкої прокрутки до певної позиції 'y' за визначений час 'duration'
function smoothScrollTo(y, duration) {
    const startingY = window.pageYOffset;// Зберігаємо поточну вертикальну позицію прокрутки
    const diff = y - startingY;// Обчислюємо різницю між поточною позицією прокрутки та позицією, до якої ми хочемо прокрутити
    let start;// Ця змінна буде використовуватися для відстеження початку анімації
    window.requestAnimationFrame(function step(timestamp) {// Функція requestAnimationFrame запускає анімацію. Ця функція викликається для кожного кадру анімації
        if (!start) start = timestamp; // Якщо змінна 'start' ще не ініціалізована, ініціалізуємо її поточним часом
        const time = timestamp - start;// Обчислюємо, скільки часу минуло з початку анімації
        const percent = Math.min(time / duration, 1);// Обчислюємо відсоток від загального часу анімації
        window.scrollTo(0, startingY + diff * percent);// Встановлюємо нову позицію прокрутки на основі відсотка від загального часу анімації
        if (time < duration) {// Якщо час анімації ще не закінчився, продовжуємо анімацію
            window.requestAnimationFrame(step);
        }
    });
}

// Змінні для відстеження позиції прокрутки
let lastScrollTop = 0;//Ця змінна слугує для зберігання позиції прокрутки під час останнього події "scroll". Її основне призначення - допомогти визначити, чи прокручує користувач сторінку вгору чи вниз. Якщо поточна позиція прокрутки більша за lastScrollTop, то користувач прокручує сторінку вниз. На початку її значення встановлено рівним 0.
let scrollDownCount = 0;//Ця змінна використовується для підрахунку кількості прокруток вниз після того, як кнопка "Завантажити ще" отримала фокус. Це допомагає реалізувати логіку, коли зображення починають завантажуватися після двох прокруток вниз. Щоразу, коли користувач прокручує сторінку вниз, ця змінна збільшується на 1.
let previousScrollTop = 0;//Ця змінна призначена для зберігання позиції прокрутки перед останнім рухом прокрутки. Ваш код використовує lastScrollTop для цієї ж мети, тому previousScrollTop може бути надлишковою, якщо вона не використовується в інших частинах коду, які я не бачив.

// Обробник події для прокрутки
// Додаємо обробник події для глобального об'єкта `window` на подію 'scroll', що спрацьовує кожен раз, коли користувач прокручує сторінку.
window.addEventListener('scroll', () => {

    // Перевірка чи користувач прокрутив до кінця сторінки (або майже до кінця, оскільки є додатковий відступ в 50 пікселів).
    // І чи це перший етап (коли користувач ще не дійшов до кнопки "Завантажити ще").
    if (scrollStage === 0 && window.innerHeight + window.scrollY >= document.body.offsetHeight - 150) {
        
        // Визначаємо нову позицію прокрутки так, щоб користувач зупинився трохи вище від кінця сторінки.
        const newScrollPosition = document.body.offsetHeight - window.innerHeight - 150 - (window.innerHeight * 0.66);
        
        // Викликаємо функцію для гладкої прокрутки до нової позиції.
        smoothScrollTo(newScrollPosition, 500);
        
        // Змінюємо стадію прокрутки на наступний, щоб наступний раз при прокрутці код реагував по-іншому.
        scrollStage = 1;
        return;
    }

    // Якщо користувач дійшов до кінця сторінки на другому етапі (після першої прокрутки).
    if (scrollStage === 1 && window.innerHeight + window.scrollY >= document.body.offsetHeight - 150) {
        
        // Показуємо кнопку "Завантажити ще".
        loadMoreBtn.style.display = 'block';
        
        // Визначаємо нову позицію прокрутки так, щоб користувач зупинився прямо перед кнопкою "Завантажити ще".
        const newScrollPosition = document.body.offsetHeight - window.innerHeight - 150;
        
        // Гладко прокручуємо до нової позиції.
        smoothScrollTo(newScrollPosition, 500);
        
        // Змінюємо стадію прокрутки на наступний етап.
        scrollStage = 2;
        return;
    }

    // Якщо користувач дійшов до кінця сторінки на третьому етапі (після другої прокрутки).
    if (scrollStage === 2 && window.innerHeight + window.scrollY >= document.body.offsetHeight - 150) {
        
        // Встановлюємо фокус на кнопку "Завантажити ще".
        loadMoreBtn.focus();
        
        // Визначаємо нову позицію прокрутки так, щоб користувач зупинився трохи вище від кнопки "Завантажити ще".
        const newScrollPosition = document.body.offsetHeight - window.innerHeight - loadMoreBtn.offsetHeight - 150;
        
        // Гладко прокручуємо до нової позиції.
        smoothScrollTo(newScrollPosition, 500);
        
        // Повертаємося до початкової стадії прокрутки.
        scrollStage = 0;
        return;
    }
});



let hasButtonFocus = false; // Змінна для відстеження фокусу на кнопці, цей рядок коду створює змінну з назвою hasButtonFocus і присвоює їй початкове значення false, вказуючи на те, що кнопка спочатку не має фокусу.let: Це ключове слово в JavaScript, яке використовується для створення змінної. Змінні можна вважати "контейнерами" для зберігання даних. hasButtonFocus: Це назва змінної. Зазвичай, назви змінних обирають так, щоб вони відображали суть даних, які зберігаються в них. У цьому випадку, назва "hasButtonFocus" може бути розглянута як питання: "Чи має кнопка фокус?". Таким чином, очікується, що змінна буде містити значення true або false (логічний тип даних).=: Це оператор присвоєння в JavaScript. Він використовується для того, щоб присвоїти значення змінній.false: Це логічне значення в JavaScript. Логічний тип даних може мати лише два значення: true (істинне) або false (хибне). У цьому випадку, змінній hasButtonFocus присвоєно значення false, що означає, що кнопка в даний момент не має фокусу.

// Обробник події для фокусу на кнопці "Завантажити ще"
loadMoreBtn.addEventListener('focus', () => {//Цей рядок додає обробник події для кнопки loadMoreBtn. Коли кнопка отримає фокус, функція, вказана у другому аргументі, буде викликана.
    hasButtonFocus = true;//Цей рядок встановлює змінну hasButtonFocus в true, що вказує на те, що кнопка loadMoreBtn в даний момент у фокусі.
    scrollDownCount = 0;//Цей рядок скидає лічильник scrollDownCount до 0. scrollDownCount використовується для відслідковування кількості прокруток вниз після отримання фокусу кнопкою. Це допомагає реалізувати логіку завантаження зображень після двох прокруток вниз.
    
    window.addEventListener('scroll', handleFocusedButtonScroll);// //Цей рядок додає новий обробник події прокрутки вікна. Коли користувач прокручує сторінку, функція handleFocusedButtonScroll буде викликана. Ця функція відповідає за обробку прокрутки, коли кнопка loadMoreBtn у фокусі.
});


// Функція для обробки прокрутки, коли кнопка "Завантажити ще" у фокусі
function handleFocusedButtonScroll() {
    // Перевіряємо, чи кнопка "Завантажити ще" в фокусі. Якщо ні, припиняємо виконання функції.
    if (!hasButtonFocus) return;

    // Отримуємо поточну позицію прокрутки вікна. 
    // Якщо window.pageYOffset не існує (для старих браузерів), то використовуємо document.documentElement.scrollTop.
    let st = window.pageYOffset || document.documentElement.scrollTop;

    // Перевіряємо, чи користувач прокручує сторінку вниз.
    if (st > lastScrollTop) {
        // Встановлюємо напрямок прокрутки як 1, що вказує на прокрутку вниз.
        scrollDirection = 1;

        // Перевіряємо, чи користувач прокрутив до кінця сторінки (з урахуванням певного відступу).
        if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 150) {
            // Якщо користувач прокрутив до кінця, збільшуємо лічильник прокруток вниз.
            scrollDownCount++;

            // Якщо користувач прокрутив вниз два рази, завантажуємо нові зображення.
            if (scrollDownCount >= 2) {
                fetchImages(currentQuery, currentPage + 1);
                // Обнулюємо лічильник прокруток
                scrollDownCount = 0;
                // Встановлюємо стан кнопки як "не в фокусі"
                hasButtonFocus = false;
                // Видаляємо цей обробник прокрутки, так як він більше не потрібен.
                window.removeEventListener('scroll', handleFocusedButtonScroll);
            }
        }
    } else {
        // Якщо користувач прокручує сторінку вгору, встановлюємо напрямок прокрутки як -1.
        scrollDirection = -1;
        // Обнулюємо лічильник прокруток вниз.
        scrollDownCount = 0;
    }

    // Оновлюємо значення останньої позиції прокрутки для наступних викликів цієї функції.
    lastScrollTop = st <= 0 ? 0 : st;
}

// Обробники подій для кнопки "Завантажити ще"
loadMoreBtn.addEventListener('click', // loadMoreBtn: Це змінна, що містить посилання на елемент кнопки "Завантажити ще" в DOM вашої веб-сторінки. addEventListener: Це вбудована метод для елементів DOM, який дозволяє призначити обробник для певної події. У цьому випадку ми слідкуємо за подією 'click'.'click': Це тип події, за якою ми слідкуємо. У нашому випадку ми хочемо реагувати на клік миші по елементу loadMoreBtn. 
() => { //Це стрілкова функція, яка викличеться, коли користувач клікає на кнопку loadMoreBtn.
    fetchImages(currentQuery, currentPage + 1);//fetchImages: Це функція, яка визначена у вашому коді і відповідає за завантаження зображень з сервісу Pixabay. currentQuery: Ця змінна містить поточний пошуковий запит користувача. Її значення використовується для завантаження відповідних зображень. currentPage + 1: Оскільки fetchImages вимагає вказівки номера сторінки для пагінації, ми передаємо наступну сторінку для завантаження. Це забезпечує завантаження наступного набору зображень, коли користувач клікає на кнопку "Завантажити ще".
});

// Додаємо обробник події "keydown" до кнопки "loadMoreBtn". 
// Ця подія спрацьовує, коли користувач натискає клавішу, поки кнопка у фокусі.
loadMoreBtn.addEventListener('keydown', (e) => {

    // Перевіряємо, чи була натиснута клавіша "Enter" (Return).
    if (e.key === 'Enter') {

        // Якщо клавіша "Enter" була натиснута, завантажуємо наступний набір зображень 
        // використовуючи поточний пошуковий запит (currentQuery) та наступну сторінку (currentPage + 1).
        fetchImages(currentQuery, currentPage + 1);
    }
});


// Обробники подій для фокусу та втрати фокусу кнопки "Завантажити ще"
loadMoreBtn.addEventListener('focus', //loadMoreBtn.addEventListener(...): ця функція встановлює обробник події для конкретного елемента DOM. У цьому випадку, елементом є кнопка "Завантажити ще", яка знаходиться у змінній loadMoreBtn. 'focus': це назва події, на яку ми хочемо відреагувати. Подія focus відбувається, коли елемент отримує фокус. Наприклад, коли користувач клікає на інпут або кнопку, або переходить до цього елемента за допомогою клавіші Tab на клавіатурі.
() => {//це стрілкова функція, яка виконується, коли відбувається подія focus. Вона служить "обробником" цієї події.
    isLoadMoreButtonFocused = true;//всередині обробника події ми встановлюємо змінну isLoadMoreButtonFocused у значення true. Це вказує на те, що кнопка "Завантажити ще" зараз у фокусі. Змінна isLoadMoreButtonFocused може використовуватися в інших частинах коду для перевірки, чи знаходиться кнопка у фокусі в даний момент часу.
});

loadMoreBtn.addEventListener('blur', //loadMoreBtn: це змінна, яка зберігає посилання на елемент кнопки "Завантажити ще" у вашому DOM (структурі веб-сторінки). .addEventListener('blur', ...): addEventListener - це метод, який дозволяє вам додавати обробники подій до елементів DOM. 'blur' - це тип події, на яку ви хочете відреагувати. Подія "blur" відбувається, коли елемент втрачає фокус. Наприклад, коли користувач клікає за межами кнопки або переходить до іншого елемента на сторінці, використовуючи клавішу Tab.
() => {//це стрілкова функція, яка буде викликана, коли відбудеться подія "blur" на loadMoreBtn. В даному випадку, ця функція не приймає аргументів.
    isLoadMoreButtonFocused = false;//в середині функції ми встановлюємо змінну isLoadMoreButtonFocused в false. Ця змінна, як видно з її назви, служить для відстеження стану фокусу кнопки "Завантажити ще". Коли кнопка втрачає фокус (тобто коли відбувається подія "blur"), ми встановлюємо цю змінну в false, що вказує на те, що кнопка більше не у фокусі.
});

// Функція для завантаження зображень
async function fetchImages(query, page = 1) {//Оголошення асинхронної функції fetchImages з двома параметрами: query (запит для пошуку) і page (номер сторінки для пагінації; якщо не вказано, за замовчуванням це 1).
    if (isFetching) return;//Якщо в даний момент вже відбувається завантаження (якщо isFetching дорівнює true), то ми виходимо з функції, щоб уникнути одночасних запитів.
    isFetching = true;//Встановлення isFetching у true, щоб вказати, що зараз відбувається процес завантаження.

    try {//Початок блоку try, який дозволить нам відслідковувати будь-які помилки, що можуть виникнути під час виконання коду в цьому блоку.
        const response = await axios.get(`https://pixabay.com/api/?key=${API_KEY}&q=${query}&image_type=photo&orientation=horizontal&safesearch=true&per_page=40&page=${page}`);//Завантажуємо дані з серверу за допомогою бібліотеки axios. Запит формується з використанням параметрів, таких як ключ API, пошуковий запит, тип зображення, орієнтація, безпечний пошук, кількість зображень на сторінці та номер сторінки.
        const images = response.data.hits;//Отримання масиву зображень з відповіді сервера.

        if (images.length === 0) {//Перевірка, чи отримані зображення. Якщо їх немає...
            Notiflix.Notify.failure('Sorry, there are no images matching your search query. Please try again.');//повідомляємо користувача про відсутність зображень за його запитом за допомогою бібліотеки Notiflix.
            loadMoreBtn.style.display = 'none';//Приховуємо кнопку "Завантажити ще", оскільки немає додаткових зображень для завантаження.
        } else {//Якщо зображення отримані...
            scrollStage = 0;//Встановлюємо етап прокрутки на початковий стадій.
            renderImages(images);//Відображаємо отримані зображення на сторінці.
            currentPage = page;//Оновлюємо номер поточної сторінки.
            if (images.length < 40 || currentPage * 40 >= response.data.totalHits) {//Перевірка, чи отримано менше зображень, ніж очікувалося (менше 40), або чи поточний номер сторінки, помножений на кількість зображень на сторінці, перевищує загальну кількість доступних зображень.
                loadMoreBtn.style.display = 'none';//Якщо умова вище виконана, приховуємо кнопку "Завантажити ще", оскільки немає додаткових зображень для завантаження.
            } else {
                loadMoreBtn.style.display = 'none';  // Якщо є ще зображення для завантаження, приховуємо кнопку "Завантажити ще" (можливо, це потребує додаткового кларифікації, оскільки логіка може здатися неінтуїтивною).
            }
        }

        // Обнулюємо прапорці та лічильники Скидання певних прапорців та лічильників після завантаження зображень.
        hasReachedEndOfImages = false;
        hasDisplayedButton = false;
        scrollCountsAfterReset = 0;
        isFetching = false;
        isLoadMoreButtonFocused = false;  // Зміна змінної на false

    } catch (error) {//В разі будь-яких помилок під час виконання коду у блоку try...
        console.error('Error fetching images:', error);//...виводимо помилку в консоль.
        isFetching = false;//Завершуємо процес завантаження, встановлюючи isFetching у false.
    }
}

// Функція для відображення зображень на сторінці
function renderImages(images) {
    // Змінна imageMarkup зберігає рядок HTML для кожного зображення у масиві images
    const imageMarkup = images.map(image => {
        // Починаємо формування HTML для окремого зображення
        return `
            <div class="photo-card">  <!-- Основний контейнер для кожного зображення -->
                <a href="${image.largeImageURL}" data-lightbox="gallery">  <!-- Посилання на велике зображення для перегляду в галереї -->
                    <img src="${image.webformatURL}" alt="${image.tags}" loading="lazy" />  <!-- Відображення зображення на сторінці з вказаними атрибутами -->
                </a>
                <div class="info">  <!-- Контейнер для додаткової інформації про зображення -->
                    <p class="info-item"><b>Likes:</b> ${image.likes}</p>  <!-- Кількість вподобань зображення -->
                    <p class="info-item"><b>Views:</b> ${image.views}</p>  <!-- Кількість переглядів зображення -->
                    <p class="info-item"><b>Comments:</b> ${image.comments}</p>  <!-- Кількість коментарів до зображення -->
                    <p class="info-item"><b>Downloads:</b> ${image.downloads}</p>  <!-- Кількість завантажень зображення -->
                </div>
            </div>
        `;
    }).join('');  // Об'єднуємо всі рядки HTML у єдиний рядок для вставки на сторінку
    
    // Вставляємо сформований рядок HTML у контейнер gallery в кінці (додаємо нові зображення до існуючих)
    gallery.insertAdjacentHTML('beforeend', imageMarkup);
    // Ініціалізуємо галерею зображень для перегляду зображень у великому форматі при кліці на них
    new SimpleLightbox('.photo-card a', {});
}

// Функція для гладкої прокрутки до початку сторінки
function smoothScrollToTop(duration) {
    // Цільова позиція прокрутки (в даному випадку - початок сторінки)
    const targetPosition = 0;
    
    // Початкова позиція прокрутки (де користувач знаходиться зараз на сторінці)
    const startPosition = window.pageYOffset;
    
    // Змінна для зберігання початкового часу анімації
    let startTime = null;

    // Внутрішня функція для анімації прокрутки
    function animation(currentTime) {
        // Якщо це перший кадр анімації, зберігаємо час початку
        if (startTime === null) startTime = currentTime;
        
        // Обчислюємо, скільки часу пройшло з початку анімації
        const timeElapsed = currentTime - startTime;
        
        // Обчислюємо, наскільки потрібно прокрутити сторінку для поточного кадру анімації
        const run = ease(timeElapsed, startPosition, targetPosition - startPosition, duration);
        
        // Прокручуємо сторінку до потрібної позиції
        window.scrollTo(0, run);
        
        // Якщо час анімації не вичерпано, запрашуємо наступний кадр
        if (timeElapsed < duration) requestAnimationFrame(animation);
    }

    // Функція для обчислення гладкої прокрутки; використовує кубічну функцію для створення ефекту "замедлення" прокрутки
    function ease(t, b, c, d) {
        t /= d / 2;
        if (t < 1) return c / 2 * t * t + b;
        t--;
        return -c / 2 * (t * (t - 2) - 1) + b;
    }

    // Запускаємо анімацію прокрутки
    requestAnimationFrame(animation);
}

